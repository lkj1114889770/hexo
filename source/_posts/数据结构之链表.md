---
title: '数据结构之链表'
date: 2019-02-21 15:37:15
tags:
	- 数据结构
---

## 定义
链表由一系列的不必在内存中连续的结构组成，每一个结构包括节点（数据域）和指向该节点之后节点的指针（指针域）构成。

	struct Node{
		int value;
		Node *next;
	}

上面即是一种典型的单向链表，还有一种双向链表，除了数据域之外，还包括分别指向上一个节点和下一个节点的指针；如果让链表最后一个节点指向第一个节点，就构成了循环链表。

## 一些例子

<!-- more -->
### 插入节点
在p之后插入值为i的节点

	void insert(Node *p, int i){
		Node* node = new Node;
		node->value = i;
		node->next = p->next;
		p->next = node;
	}

### 删除节点
删除某个节点p时，只需要用p后一个节点覆盖p当前节点：

	void delete(NOde *p){
		p->value = p->next->value;
		p->next = p->next->next;
	}

### 找出倒数第k个节点
采用连个指针p1,p2，p1先走k步，然后p1和p2一起走，当p1到达节点终点时，p2即指向倒数第k个节点。

	Node* findk(Node* head, int k){
		Node *p1 = head;
		Node *p2 = head;
		for(int i=0;i<k;i++){
			if(p1==NULL) return NULL;
			p1=p1->next;
		}
		while(p1->next !=NULL && p2->next != NULL){
			p1=p1->next;
			p2=p2->next;
		}
		return p2;
	}

同样的道理，如果要找出链表的中间节点，可以令p1和p2分别以前进2步、前进1步的速度遍历，当p1到达节点终点时，p2即指向终点节点。

### 判断是否有环
直观的判断是，存在环路的时候，一直遍历都不会遇到NULL节点，但是由于不知道链表的长度吗，所以采用这种判断不知道多久才能终止。转化成一个追及问题，如果有环，那么两个遍历速度不一致的指针一定会相遇，采用类似上面，有两个指针pslow，pfast,pslow每次走一步，pfast每次走两步，若是有环，pfast就能追上pslow，否则pfast会碰到NULL。

	bool isLoop(Node* head){
		if(head==NULL) return false;
		Node* pfast = head;
		Node* pslow = head;
		while(pfast!=NULL){
			if(pfast->next==NULL) return false;
			pslow = pslow->next;
			pfast = pfast->next->next;
			if(pfast==pslow) return true;
		}
		return false;
	}

### 反向遍历
可以采用先将链表存在栈中，然后先进后出即为反向遍历：

	void reverse(Node* head){
		stack<Node*> nodestack;
		Node* p = head;
		while(p!=NULL){
			nodestack.push(p);
			p=p->next;
		}
		while(!nodestack.empty()){
			cout<<nodestack.top().value<<endl;
			nodestack.pop();
		}
	}

或者是采用递归的方法：

	void reverse(Node* head){
		if(head!=NULL){
			if(head->next!=NULL){
				reverse(head->next);
			}
			cout<<head->value<<endl;
		}
	}

### 链表反转
采用就地反转法，有一篇博客讲的很清楚[https://www.cnblogs.com/byrhuangqiang/p/4311336.html](https://www.cnblogs.com/byrhuangqiang/p/4311336.html "https://www.cnblogs.com/byrhuangqiang/p/4311336.html")，这里就转载一下人家的方法，主要思路就是把当前链表的下一个节点PCur插入到头结点dummy的下一个节点中，就地反转。
dummy->1->2->3->4->5的就地反转过程：
dummy->2->1->3->4->5
dummy->3->2->1->4->5
dummy->4>-3->2->1->5
dummy->5->4->3->2->1

初始状态为：

<img src="/img/LinkedList/reverseList1.png" width="300" hegiht="150" align=center />

pCur指向每一次需要反转的节点，将prev对应的节点连接到下一个需要反转的节点，将pCur连接的当前需要反转的节点作为插入到dummy之后，即移到了头部，调整pCur指向下一个需要反转的节点，这样循环直到下一个需要反转的节点为NULL，其动态过程如下图：


<img src="/img/LinkedList/reverseList2.png" width="300" hegiht="450" align=center />

	Node* reverseList(Node* head){
		if(head==NULL) return head;
		Node* dummy = new Node;
		dummy->next = head;
		Node* prev = dummy->next;
		Node* pCur = prev->next;
		while(pCur!=NULL){
			prev->next = pCur->next;
			pCur->next = dummy->next;
			dummy->next = pCur;
			pCur = prev->next;
		}
		return dummy->next;
	}

### 链表相交
两个链表相交，则相交之后必重合，从交点到末尾节点均相同。那么如果两个链表p1，p2相交的话，首先假设获得链表的长度分别为m，n，那么让较长的先走|m-n|步，再同步走的话，如果两个链表相交，那么p1，p2指针必定会相撞。


<font face="微软雅黑" color=black size=4>**参考**</font>

[https://www.cnblogs.com/byrhuangqiang/p/4311336.html](https://www.cnblogs.com/byrhuangqiang/p/4311336.html "https://www.cnblogs.com/byrhuangqiang/p/4311336.html")
[https://www.cnblogs.com/byonecry/p/4458821.html](https://www.cnblogs.com/byonecry/p/4458821.html "https://www.cnblogs.com/byonecry/p/4458821.html")